Types of Requirements
          We’re really talking about functional requirements, the list of features the user will see and be able to use when they fire up your program. These are the “black box” requirements that show the external behavior of your program. As far as the user is concerned these are the only requirements that matter. In a plan-driven process the output of this activity of identifying requirements is a functional specification of what the software system is supposed to do. For an agile process the output is a set OF user stories that define the product backlog.

3.1 Type of Requirements

          We have four type of requirements: user requirements, domain requirements, non-functional requirements, and non-requirements. User requirements are nearly always expressed in natural language. They are the details of what the user expects to see as they use the program. They also include descriptions of screen layouts, dialog boxes, and menus. Any interaction element in the program should be described in the user requirements. For example:

               Logging into the system: When Gloria clicks the Login button on the mainpage, a Login dialog box appears in the middle of the screen. The Login dialog must contain two text boxes, labeled “Username” and “Password.” There must also be two buttons in the dialog box, labeled “Submit” and “Cancel.”



                In normal usage, she will click in the Username text box and type in her username, and then click in (or tab to) the Password text box and type in her password. The text typed in the Password text box must be hidden. Once Gloria is finished typing in her username and password she must click the Submit button. If she has entered a correct user name/password combination she will then be taken to the main menu page. If Gloria’s user name/password combination is  incorrect, an “Invalid username or password, please try again” message shall appear in the dialog box, the text boxes shall be cleared, and she will be given the opportunity to login again.

               As seen in this section, you can express user requirements as scenarios, anas detailed screen-by-screen descriptions. Remember to use pictures as much as
        you can when you’re doing user requirements


        Domain Requirements

                These are requirements that are imposed on you by the application domain of the program. If you’re writing a new version of an income tax program, you will be constrained by the latest IRS regulations. A general ledger program will have to abide by the latest edition of the Generally Accepted Accounting Principles (GAAP), and a smartphone will need to implement the latest Global System for Mobile communication (GSM) protocols. You don’t need to write down all these requirements, just refer to them.

                A set of detailed domain requirements gives the developers information the will need during the design of the program. Domain requirements are usually considered “middle layer” software because they are the heart of the application, below the user interface and above the operating system, networking, or database software.


                A lot of domain requirements will get implemented as separate classes and libraries with their own APIs. Users are concerned with domain requirements only as they affect the user requirements.

Non-Functional Requirements
Non-functional requirements are constraints on the services and functions of the program and also expectations about performance. They can include target platform specifications, timing constraints, performance requirements, memory usage requirements, file access privileges, security requirements, response times, minimum number of transactions per second, and so on. These are usually requirements that may not be visible to the user, but that do effect the user experience. An example of this type of requirement is that your web page must load and display within three seconds.


Non-Requirements
These are the things you’re not going to do. You will need to communicate this to the customer because after laying out what the program will do, the most important thing to do in the requirements phase is manage expectations. One of the worst phrases a customer can utter at that final demo before you release is, “But I thought it was going to do . . .” You need to tell all the stakeholders in a project what the program is going to do and also what it’s not going to do.
In particular you need to let them know that there are requirements that won’t be implemented—at least not in the current release. “Only one countdown timer may run at a time.” “There will not be a defrost cycle that allows defrost modes to be selected by food type.” It’s likely that your customer won’t read this section, but at least you can point to it when they ask.
3.2 Requirements Gathering in Plan Driven Design
                A functional specification describes what the program will do entirely from the user’s perspective. It doesn’t care how the software is implemented. It talks about the features of the program and specifies screens, menus, dialogs, and the like. Think of it as a badly written user manual. A second kind of spec can be called a technical specification. The technical specification describes the internal implementation details of the program. That is, it talks about data structures, algorithms used, database models, choice of programming language, and so on.
Outline of a Functional Specification
Every function specification should have the elements discussed in the following sections.
        1. Overview
                This is your executive summary. A paragraph or at most two of what the program is supposed to do. “This program runs your microwave oven. It interfaces to a keypad and an LCD display that provides user input and output functionality. Its functions are limited to those that a standard microwave would have, with the addition of single buttons for pizza and coffee reheating. It also will run a time of day clock and a standalone countdown timer. It doesn’t control the light. It has a safety interlock that will prevent the microwave from starting if the door is open.”
        2. Disclaimer
                You should always put in a statement right at the beginning that “This specification isn’t done yet. If you think something is missing or wrong, just sent me an email.” That helps keep all the marketing guys off your back and lets you file new feature requests in your mail trash bin.
                Lots of people will put a big, black DRAFT in the header or footer of the document. That can work as well, but folks tend to ignore it. Some people will use a big DRAFT watermark on their specs, so that every page has the word embedded behind the text. At some point your disclaimer should change to something like  “This specification is as complete as it will be for this release. If you think something is missing or wrong, just sent an email to the author and we’ll consider it for the next release.”

        3. Author’s Name
               Somebody needs to be responsible for the functional specification. Not a committee, not the development team, one person. This is usually either the development manager or the project manager, depending on how your company sets up development projects. There are pros and cons to all the different organizational arrangements.
               If the development manager (the person to whom the developers report) is in charge of the functional spec, then that person is usually up to speed on all the technical aspects of the project. That’s good. On the other hand, if your boss writes the functional spec, it might be harder to tell them that there’s something wrong with the specification, or that you don’t agree with the design.
               Also, development managers were probably developers at one time and so they may not have the people skills necessary to talk to marketing, the customer, documentation, testing, and so on. If your company uses project managers that are in charge of the specification, design, and schedule, but don’t have developers directly reporting to them, then you run the risk of getting someone that isn’t as technically astute as a former developer. Project managers need to have some technical skills and to be very good at getting all the stakeholders to reach consensus on the contents of the functional specification.
4. Scenarios of typical Usage

               These are the actual requirements. A great way to get customers to respond to your requirements list is to present several scenarios of typical usage of the program to them as part of the specification. This has a couple of advantages:
         First, if you write the scenarios as if they’re user stories, the customer is more likely to read them.
         Second, customers are more likely to understand what you’re doing and come up with ideas for things you’ve missed or gotten wrong. This is always a good thing, because the more customer input you get early in the process, the more likely you’ll actually create something they want.

3.2 Requirements Gathering in
Plan Driven Design
                In many agile methodologies, including XP, user stories are often written like scenarios. In XP, the customer is part of the project team, so you get constant feedback on user stories and daily program builds. In Scrum, the customer isn’t required to be part of the project team, but they are strongly encouraged to keep in close contact with the team. Also in Scrum, shorter sprint lengths allow the customer to see working versions of the product more often. In the Unified Modeling Language (UML), there is an entire notation used to create use cases (another word for scenarios).
        5. Open Issues
                When you first write the functional specification, there will be one or two things you don’t know. That’s okay. Just put them in the “Open Issues” section. Then every time you meet with the customer, point to this section and try to get answers.
                Some of these questions will move to requirements sections and some will end up in the “Non-requirements” section, after you get those answers. By the end of the project, though, this section should be empty.
        6. Design and New Feature Ideas
               If you’re like most developers, you’ll be trying to design and code the program in your head all the time you’re doing your requirements gathering and analysis. That’s just what developers do. The two types of notes developers and project managers typically create are technical notes containing design or coding ideas for developers, and marketing notes containing feature ideas for the marketing folks and the customer. So, to keep from forgetting the design and implementation ideas you have during the requirements phase, write a separate notebook.
                Finally, as your project proceeds through development, new requirements and features will surface. This always happens. But if you want to keep to a schedule and deliver a working product, you just can’t implement everything that will come up. If you want your requirements to be up to date, you need a place to put all the tasks you will do later.

                That’s what a “Backlog” document is for—all the requirements you’re going to consider for the next release of the product. This does a couple of good things for you. It tells the customer you haven’t forgotten these features, and that by moving them to the next release you are committed to delivering the current release as close to the published schedule as possible. And it tells the developers that you’re not out of control and that the project has a good shot at being done with high quality and on time.
        One More Thing
                One more thing about the functional specification: don’t obsess. Chances are, you’ll do a good job of picking out requirements and writing them down in the functional spec, but it won’t be as detailed as you like and it won’t be complete. The only time a functional specification is complete is when you ship the release. Don’t spend time trying to get every single detail correct; don’t spend time trying to tease every requirement out of your customer. It just won’t happen. Set a time limit, do your best, and let it go.

3.3 Requirements Gathering in an Agile Project
               For most agile methodologies the key idea in requirements gathering is the user story. The user story is just that—a description of some feature or scenario that the customer wants to execute in order to get some type of work done. The classic way to describe the contents of a user story is to say, “As a , I want to do , so that .” By expressing a user story this way, you get to the who, what, and why of the requirement
        The Three Cs
A user story has three fundamental components, expressed by Ron Jeffries in 2001: the card, the conversation, and the confirmation.
        Card
                All user stories are written on cards. A card can be a Post-It note, an index card, or a larger piece of paper. But it’s nearly always a physical thing. Although the card contains the text of the story “As a I want to so that ,” it’s really an invitation to a collaborative conversation about what the story really means and what the user really wants. Note that the card isn’t very detailed. It usually just contains an outline of the story. It’s a placeholder for the real requirement that will be subsequently hashed out. Stakeholders can write on the card, put estimates on it, questions, and so forth.
        Conversation

                The conversation about a user story takes place between all the important stakeholders in the project, the product owner or user, the development team, the testers, marketing folks, and maybe others. This is a substantive discussion about what the product owner really wants from the story. The conversation is ideally held in person, and the discussion will include more details about the story, possibly estimates of size, and an estimate of the relative priority of the story. The conversation may include breaking the original story into two or more smaller stories if the initial estimates indicate the effort to implement the story may be too large.

        Confirmation
                The last component of a user story is confirmation. The user or product owner provides this information in the form of acceptance criteria for the story. The acceptance criteria are usually written on the back of the card as a short bullet list. These criteria will end up being acceptance tests that the product owner will use to confirm that the implementation of the story is acceptable to the user. The best way to create acceptance tests is for the product owner to generate examples of the story in use and then for the development team to automate the examples. That way, the product owner can execute the acceptance tests on the delivered feature and confirm whether the implementation works or not.
        INVEST in Stories
               Note that the three components of a user story just mentioned don’t tell us all about the story. A lot of the details will come out of the conversation and the confirmation. They also don’t tell us anything about the quality of the story and what makes a good user story. Bill Wake, in a classic blog post, laid out the characteristics of a good user story using the acronym INVEST.
         Independent
               The idea here is that your user stories should be independent of each other. That way a single user story can be scheduled and implemented separately from any other user story. Wake gives the example of a multilayered cake.
                If you take a slice out of the cake, you can eat (implement) just that one slice, independently of any other. This may not be completely possible—think of things like the radio software in a mobile phone. In order to fully test part of the user interface embodied in a user story, you may have to have all the radio software working first. We’ll see this same idea later on as loose coupling in object-oriented design.
         Negotiable
                A good story leaves room for the parties involved to negotiate the details of its implementation; it provides the essence of the requirement. The story is not so specific that it reads like a contract. Rather it provides the developer with a goal and allows the owner and the developer room to create an interesting and workable implementation.
         Valuable
               A good user story must be valuable to the customer. It must describe a feature or a service that the customer wants. Because user stories will be scheduled and implemented in a development iteration, they must add value to the product when the iteration is complete. In addition, if the team decides a user story is too large and must be split into two or more stories, each of them must provide value to the customer. This idea gives the development team guidance on how to split stories—based on value to the customer, not on technology
        Estimable
              User stories must be able to be estimated. Estimation is critical to the product owner so that they can assign a relative priority to the story.
                This characteristic also allows the team to focus on the size of the story. Stories that are too large can’t really be estimated and so should be candidates for splitting. Estimation is part of the negotiation in the conversation. It means to look at both the size of the story and the possible effort involved in implementing it. If a team is having trouble estimating the size or the effort of a particular story, it may be that the story is too large and needs to be split. Estimation is also the first step in decomposing the story into implementable tasks.
       Small
               As implied above, good user stories should be small. Ideally, a user story should be implementable in a single sprint or iteration.
                That will allow the development team to decompose the story into a number of small tasks—ideally of eight person-hours or less worth of effort. It also speaks to the Value characteristic because if it’s small, the story will add value for the customer at the end of a single iteration.

                 One way to manage story sizes is to not care about them if the story is low priority. As the story moves up in the product backlog, it will become more important, and at some point it will be important enough to do a detailed estimate of its effort. If large enough you should consider splitting it into smaller stories.
        Testable
                Good stories must be testable. This harkens back to the plan-driven idea of traceability. Once implemented, one should be able to trace a feature back through the implementation and design and into the original requirements. In agile, this practice is usually implemented using test-driven development (TDD) and acceptance criteria. The product owner writes the acceptance criteria, and the developers will implement the unit tests that will confirm that a task is correct. The acceptance tests the product owner will use confirm that the user story is correctly implemented.
                This is typically the definition of Done in an agile environment. If a user story is written and the product owner is unsure or unclear about how to write the acceptance criteria, this may mean that the story details are unclear and the story conversation should be restarted to clear up any confusion. The Testable characteristic is also a way for the development team to include non-functional requirements (performance, response time, usability, and so on) as things to be tested.
        Product Backlog
At this point, the total number of user stories generated by the product owner and agreed upon by the development team is added to a list of the total number of things that need to be done to create the product. This is known as the product backlog. Where a plan-driven process team will have a long, detailed document—the functional specification—an agile product team will have a stack of cards that ends up defining the product.

               As the development process moves along, an agile product team will be adding, removing, and dividing user story cards constantly. The product owner will be the primary person doing this job, and it’s the product owner’s job to decide when the product is done and should be released. There may still be cards left in the stack when a product is released. Those cards are destined for the next product version.
        SMART Tasks
                Once the team agrees on a set of user stories and adds them to the product backlog, the developers must then plan for the next iteration or sprint. This planning includes taking each user story and breaking it down into a set of implementable tasks, each of which is easy to estimate with effort requiring a relatively short amount of developer time. In short, tasks are the work to be done in order to implement user stories
         Specific
               Where user stories can be general and leave room for interpretation and negotiation, the tasks created from them need to be specific so they can be implemented. This will likely uncover hidden requirements in the stories.
                These requirements can be incorporated into the tasks or they may require the creation of a new user story that will then get put in the product backlog. In any event, tasks should be as specific as possible, including details about data structures and user interfaces if necessary.
         Measurable
               The key idea here is that the team needs to know when all the requirements for the task have been completed. That is, when is the task done? Each team will have a different definition of done, but it should include things like “the feature works as listed on the task,” “all the unit tests pass,” and “the code has been reviewed and integrated.”
        Achievable
                 The task must be something that a developer can do within the timeframe of the iteration or sprint. The developer must also have the skill set necessary to achieve the task. This doesn’t mean the developer can’t ask for help. This goal can also integrate well with the idea of pair programming, which will spread the required skill set across two developers.
         Relevant

                This goal ties in with the Valuable story component discussed earlier. With respect to tasks, this means that the task must do something that makes progress towards the creation of the user story implementation. It should add value to the iteration for the customer.

         Time-Boxed
                This goal means that the task, as estimated, can be finished within the iteration or sprint. If the task turns out to be harder than expected, the team is expected to divide it into two or more tasks and estimate them separately. The other goal implied here is that the total number of points assigned to the tasks included in the iteration is doable within the team’s average velocity.

        Sprint/Iteration Backlog
                As the tasks are created from user stories and estimated, they’re added to the sprint/iteration backlog as things to do in the next sprint or iteration. Depending on the agile methodology being used, once an agreed-upon number of tasks are added =to the backlog, the number of tasks in the backlog may or may not be changed while the sprint or iteration is underway. In Scrum, no more tasks may be added, except by the developers themselves, for the duration of the sprint. Any new work that’s discovered must be added to the product backlog instead.
               Most software engineering texts use the phrase requirements elicitation to talk about the process of getting your users to tell you what they want. Hunt and Thomas, in their book The Pragmatic Programmer, use the much more descriptive phrase requirements digging to emphasize the point that what you’re really doing is digging for all those requirements that your customer doesn’t know they want yet. Hunt and Thomas also make the terrific distinction between requirements, policies, and implementations as a way to illustrate the requirements digging process.
                For example, “The system must let the user choose a loan term” is a concise requirement. It says that there’s something you have to do. It isn’t specific enough for implementation yet, but it tells the developer something concrete that must be built. “Loan terms must be between 6 months and 30 years” isn’t a requirement, although it kind of looks like one. This statement is an example of a business policy.

               When statements like this are presented to developers as requirements, they have a tendency to hard-code the statement in the program. Policies like this can change, so you need to be very careful about putting business policies in your requirements. It’s almost always the case that you need to implement a more general version of the business policy than is stated.
                The real requirement is probably something like “Loan terms are of finite length but the length of the loan will vary by type of loan.” This tells you that you probably need to build a table-driven subsystem to handle this feature. That way, the loan term for a particular type of loan can be changed by making a single change in a data table, and the code doesn’t need to change at all.

                “The user must be able to select a loan term using a drop-down list box” isn’t a requirement either, although, again, it may look like one. This is only a requirement if the customer absolutely must have a drop-down menu to choose their loan term. Otherwise, this is an example of the implementation that the customer would like to see, and it may not be a requirement.

Why Requirements Digging Is Hard
                There are several reasons why pulling requirements out of your customer is a really hard exercise.
        1. Problems of Scope
                 Lots of times the boundaries of what your program is supposed to do are fuzzy. This can be because of several things. The program may be part of a larger system, and the integration of the parts is ill-defined. The customer may not have thought through exactly what they want the program to do, so they start throwing out all sorts of ideas, many of which may not even apply to the problem at hand. Finally, the customer may have dropped into implementation-land and be providing unnecessary levels of detail.
        2. Problems of Understanding
               Let’s face it: the customer and you as the developer speak different languages. Your customer is the domain expert and they speak the domain language. You speak the design and implementation language.
                There are usually two ways to overcome problems of understanding. The first is to have someone in the middle who has lived in both worlds and who can translate between the two. Some companies have folks called system engineers or technical marketers who fulfill this role. These folks have done development and have also worked the customer side of things, so they can speak both languages. Good system engineers are worth their weight in user stories.
               The second way to promote understanding is to have the customer as part of the development team. This is the approach taken by some agile methodologies, notably XP. When the customer is part of the development team, you get to talk to them every day, ask them questions, and teach them technical stuff. Both sides benefit. And because the on-site customer sees intermediate product builds as soon as they pop out of your build machine, you get immediate feedback.

3. Problems of Volatility
                Things change. This is by far the hardest part of requirements gathering and analysis and the biggest reason why schedules slip. You can’t do anything about it. Get used to it. As Kent Beck says, “Embrace change.” What you can do is manage change. Create a backlog of new features that get added as they arrive.
                In the Scrum methodology, new requirements are always added to the product backlog—they’re not added to the current sprint backlog. This allows the current sprint to proceed normally, and the requirements are all reviewed at the end of the sprint.
               Another way to manage change is to push the decision onto the user. Give the user a choice: “If we implement this new feature it will add six weeks to the schedule. Do you still want it?” Alternatively: “If you want to keep to the original schedule, we can only implement and test one of A, B, or C. You pick the one you want most.” This is one of the things that the agile folks mean by courage; sometimes you have to take a stand and choose what’s best for the project as a whole.
        Non-Technical Problems
               From a developer’s perspective, non-technical problems with requirements are the worst ones you will see. In fact, these are problems developers should never see; their managers should shield them from nontechnical problems. Non-technical requirements problems are fundamentally political. One group of customers in an organization has a different view of the program requirements than another group. Or worse, one manager has a different view than another manager.
               The program being developed will reduce the influence of one department by automating a function where they used to be the sole source of expertise. The program will distribute data processing across several departments where it was once centralized in a single department.
